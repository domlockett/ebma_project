library(devtools)
install_github("fhollenbach/EBMA", subdir="EBMAforecast")
library(gtools)
library(stringr)
set.seed(123)
N <- 400
nmod <- 4
W.matrix <- matrix(NA, nrow=N, ncol=nmod)
alpha <- c(10,5,3,1)
W.matrix <- rdirichlet(N, alpha) #drawing weights, given alphas specified above
#
#
# ##vector to select obs from different models
prob<-runif(N)
#
selection<-function(probability, matrix){
models<-dim(matrix)[2]
obs<-dim(matrix)[1]
interval<-matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
position<-matrix(as.numeric(((probability<=interval))),ncol=models,nrow=obs)
pos<-rowSums(position)
pos.1<-(pos*(-1))+(models+1)
W.indicator<-pos.1
return(W.indicator)
}
#
select.vec <- selection(prob,W.matrix)
probability = 0.7
matrix <- W.matrix[1,]
models<-dim(matrix)[2]
obs<-dim(matrix)[1]
interval<-matrix
matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
models <- 4
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
matrix
dim(matrix)
obs = 1
interval<-matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
matrix <- matrix(matrix, nrow = 1, ncol =4)
models<-dim(matrix)[2]
obs<-dim(matrix)[1]
interval<-matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
models
i = 1
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
i =2
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
matrix[,1:i]
rowSums(matrix[,1:i])
dim(matrix)
matrix <- as.matrix(matrix, nrow = 1, ncol =4)
dim(matrix)
interval[,i]<-rowSums(matrix[,1:i])
interval[,i]<-rowSums(matrix[1,1:i])
interval[,i]<-Sums(matrix[,1:i])
interval[,i]<-sum(matrix[,1:i])
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-sum(matrix[,1:i])
}
interval
position<-matrix(as.numeric(((probability<=interval))),ncol=models,nrow=obs)
position
pos<-rowSums(position)
pos.1<-(pos*(-1))+(models+1)
W.indicator<-pos.1
W.indicator
set.seed(123)
N <- 400
nmod <- 4
W.matrix <- matrix(NA, nrow=N, ncol=nmod)
alpha <- c(10,5,3,1)
W.matrix <- rdirichlet(N, alpha) #drawing weights, given alphas specified above
#
prob<-runif(N)
#
selection<-function(probability, matrix){
models<-dim(matrix)[2]
obs<-dim(matrix)[1]
interval<-matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
position<-matrix(as.numeric(((probability<=interval))),ncol=models,nrow=obs)
pos<-rowSums(position)
pos.1<-(pos*(-1))+(models+1)
W.indicator<-pos.1
return(W.indicator)
}
#
select.vec <- selection(prob,W.matrix)
#
# ##creation of observations for predictions
m1 <- rnorm(N, 40, 10)
m2 <- rnorm(N, 0, 1)
m3 <- rnorm(N, -10, 10)
m4 <- rnorm(N, 15, 5)
predictions <- cbind(m1, m2, m3, m4)
#
# ##creation of DV with use of selection vector
##creation of DV with use of selection vector
DV <- means <- matrix(NA, nrow=N)
for(i in 1:N){
means[i,] <- predictions[i, select.vec[i]]
}
DV<-rnorm(N, mean = means, sd=2)
#
test.normal <- makeForecastData(.predCalibration=predictions[1:399,],.outcomeCalibration=DV[1:399]) #create the dataframe to run EBMA algorithm
thisEnsemble.em <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, const=0, method = "EM") #run EBMA algorithm on data
library(EBMAforecast)
prob<-runif(N)
#
selection<-function(probability, matrix){
models<-dim(matrix)[2]
obs<-dim(matrix)[1]
interval<-matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
position<-matrix(as.numeric(((probability<=interval))),ncol=models,nrow=obs)
pos<-rowSums(position)
pos.1<-(pos*(-1))+(models+1)
W.indicator<-pos.1
return(W.indicator)
}
#
select.vec <- selection(prob,W.matrix)
#
# ##creation of observations for predictions
m1 <- rnorm(N, 40, 10)
m2 <- rnorm(N, 0, 1)
m3 <- rnorm(N, -10, 10)
m4 <- rnorm(N, 15, 5)
predictions <- cbind(m1, m2, m3, m4)
#
# ##creation of DV with use of selection vector
##creation of DV with use of selection vector
DV <- means <- matrix(NA, nrow=N)
for(i in 1:N){
means[i,] <- predictions[i, select.vec[i]]
}
DV<-rnorm(N, mean = means, sd=2)
#
test.normal <- makeForecastData(.predCalibration=predictions[1:399,],.outcomeCalibration=DV[1:399]) #create the dataframe to run EBMA algorithm
thisEnsemble.em <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, const=0, method = "EM") #run EBMA algorithm on data
summary(thisEnsemble.em)
weights<-apply(W.matrix,2,mean)
weights
select.vec
select.vec <- rmultinom(n =N, size = 1,prob =W.matrix)
select.vec
W.matrix
select.vec <- rmultinom(n = N, size = 1,prob = W.matrix)
dim(select.vec)
head(select.vec)
select.vec <- rmultinom(n = 1, size = 1,prob = W.matrix[1,])
select.vec
W.matrix[1,]
select.vec <- rmultinom(n = 1, size = 1,prob = W.matrix[1,])
select.vec
select.vec <- rmultinom(n = 1, size = 1,prob = W.matrix[1,])
select.vec
select.vec <- rmultinom(n = 100, size = 1,prob = W.matrix[1,])
select.vec
rowMeans(select.vec)
for(i in 1:N){
select.vec[i,] <- rmultinom(n = 1, size = 1,prob = W.matrix[i,])
}
N
#
select.vec <- selection(prob,W.matrix)
for(i in 1:N){
select.vec[i,] <- rmultinom(n = 1, size = 1,prob = W.matrix[i,])
}
dim(W.matrix)
for(i in 1:N){
select.vec[i,] <- t(rmultinom(n = 1, size = 1,prob = W.matrix[i,]))
}
for(i in 1:N){
select.vec[i,] <- c(1,2,3,4)[rmultinom(n = 1, size = 1,prob = W.matrix[i,])]
}
#
select.vec <- selection(prob,W.matrix)
select.vec
#
select.vec <- selection(prob,W.matrix)
for(i in 1:N){
select.vec[i] <- c(1,2,3,4)[rmultinom(n = 1, size = 1,prob = W.matrix[i,])]
}
#
# ##creation of observations for predictions
m1 <- rnorm(N, 40, 10)
m2 <- rnorm(N, 0, 1)
m3 <- rnorm(N, -10, 10)
m4 <- rnorm(N, 15, 5)
predictions <- cbind(m1, m2, m3, m4)
#
# ##creation of DV with use of selection vector
##creation of DV with use of selection vector
DV <- means <- matrix(NA, nrow=N)
for(i in 1:N){
means[i,] <- predictions[i, select.vec[i]]
}
DV<-rnorm(N, mean = means, sd=2)
#
test.normal <- makeForecastData(.predCalibration=predictions[1:399,],.outcomeCalibration=DV[1:399]) #create the dataframe to run EBMA algorithm
thisEnsemble.em <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, const=0, method = "EM") #run EBMA algorithm on data
thisEnsemble.em@modelWeights
weights
#
select.vec2 <- selection(prob,W.matrix)
select.vec1 <- rep(NA, N)
for(i in 1:N){
select.vec1[i] <- c(1,2,3,4)[rmultinom(n = 1, size = 1,prob = W.matrix[i,])]
}
select.vec1
select.vec2
c(1,2,3,4)
rmultinom(n = 1, size = 1,prob = W.matrix[i,])
c(1,2,3,4)[t(rmultinom(n = 1, size = 1,prob = W.matrix[i,]))]
t(rmultinom(n = 1, size = 1,prob = W.matrix[i,]))
c(1,2,3,4)[t(rmultinom(n = 1, size = 1,prob = W.matrix[i,]))]
rmultinom(n = 1, size = 1,prob = W.matrix[i,])
which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
select <- which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
select
select <- which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
select
select <- which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
select
for(i in 1:N){
select.vec1[i] <- which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
}
select.vec1
#
# ##creation of DV with use of selection vector
##creation of DV with use of selection vector
DV <- means <- matrix(NA, nrow=N)
for(i in 1:N){
means[i,] <- predictions[i, select.vec1[i]]
}
DV<-rnorm(N, mean = means, sd=2)
#
test.normal <- makeForecastData(.predCalibration=predictions[1:399,],.outcomeCalibration=DV[1:399]) #create the dataframe to run EBMA algorithm
thisEnsemble.em <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, const=0, method = "EM") #run EBMA algorithm on data
thisEnsemble.em@modelWeights
thisEnsemble.em <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, const=0, method = "EM") #run EBMA algorithm on data
thisEnsemble.em@modelWeights
weights
library(gtools)
library(stringr)
set.seed(123)
N <- 400
nmod <- 4
W.matrix <- matrix(NA, nrow=N, ncol=nmod)
alpha <- c(10,5,3,1)
W.matrix <- rdirichlet(N, alpha) #drawing weights, given alphas specified above
#
#
# ##vector to select obs from different models
prob<-runif(N)
#
selection<-function(probability, matrix){
models<-dim(matrix)[2]
obs<-dim(matrix)[1]
interval<-matrix
for(i in 2:models){
interval[,1]<-matrix[,1]
interval[,i]<-rowSums(matrix[,1:i])
}
position<-matrix(as.numeric(((probability<=interval))),ncol=models,nrow=obs)
pos<-rowSums(position)
pos.1<-(pos*(-1))+(models+1)
W.indicator<-pos.1
return(W.indicator)
}
#
select.vec2 <- selection(prob,W.matrix)
select.vec1 <- rep(NA, N)
for(i in 1:N){
select.vec1[i] <- which(rmultinom(n = 1, size = 1,prob = W.matrix[i,])==1)
}
#
# ##creation of observations for predictions
m1 <- rnorm(N, 40, 10)
m2 <- rnorm(N, 0, 1)
m3 <- rnorm(N, -10, 10)
m4 <- rnorm(N, 15, 5)
predictions <- cbind(m1, m2, m3, m4)
#
# ##creation of DV with use of selection vector
##creation of DV with use of selection vector
DV <- means <- matrix(NA, nrow=N)
for(i in 1:N){
means[i,] <- predictions[i, select.vec1[i]]
}
DV<-rnorm(N, mean = means, sd=2)
#
test.normal <- makeForecastData(.predCalibration=predictions[1:399,],.outcomeCalibration=DV[1:399]) #create the dataframe to run EBMA algorithm
thisEnsemble.em <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, const=0, method = "EM") #run EBMA algorithm on data
thisEnsemble.gibbs <- calibrateEnsemble(test.normal, model = "normal", useModelParams=F, modelPriors = rep(0.00001, 4), method = "gibbs") #run EBMA algorithm on data
weights<-apply(W.matrix,2,mean)
weights
thisEnsemble.em@modelWeights
colMeans(thisEnsemble.gibbs@posteriorWeights)
tyn=400
a=1
train.years=399
dates <- seq(as.Date("2010-01-01", ), length.out = 400, by = "1 day")
dates <- as.character(dates) %>%
str_remove("-") %>%
str_remove("-")
pred.date <- dates[400]
full.forecasts<-predictions
full.observed<-DV
library(ensembleBMA)
my.E.data <- ensembleData(forecasts=(full.forecasts)^(1/a), dates = dates, observations=full.observed,initializationTime=1, forecastHour=1) #Make a dataset of the appropriate format for the ensembleBMA package
fit.eBMA <- ensembleBMAnormal(my.E.data, trainingDays=train.years, dates=pred.date, minCRPS=FALSE,
control=controlBMAnormal(biasCorrection="none",tol=0.000000001))
round(weights,2)
round(thisEnsemble.em@modelWeights,2)
round(colMeans(thisEnsemble.gibbs@posteriorWeights),2)
round(fit.eBMA$weights,2)
#### with missingness
missing <- matrix(data <- sample(c(FALSE, TRUE), prob = c(0.9, 0.05),1600, replace = TRUE), nrow = 400)
missingPred <- predictions
missingPred[missing] <- NA
test.normal.missing <- makeForecastData(.predCalibration=missingPred,.outcomeCalibration=DV) #create the dataframe to run EBMA algorithm
thisEnsemble.em.missing <- calibrateEnsemble(test.normal.missing, model = "normal", predType = "posteriorMedian", useModelParams=T, const=0, method = "EM") #run EBMA algorithm on data
thisEnsemble.gibbs <- calibrateEnsemble(test.normal.missing, model = "normal", useModelParams=F, modelPriors = rep(0.00001, 6), const=0, method = "gibbs") #run EBMA algorithm on data
thisEnsemble.em.missing <- calibrateEnsemble(test.normal.missing, model = "normal", useModelParams=T, const=0, method = "EM") #run EBMA algorithm on data
missing
#### with missingness
missing <- matrix(data <- sample(c(FALSE, TRUE), prob = c(0.9, 0.05),1600, replace = TRUE), nrow = 400)
missingPred <- predictions
missingPred[missing] <- NA
test.normal.missing <- makeForecastData(.predCalibration=missingPred,.outcomeCalibration=DV) #create the dataframe to run EBMA algorithm
thisEnsemble.gibbs <- calibrateEnsemble(test.normal.missing, model = "normal", useModelParams=F, modelPriors = rep(0.00001, 4), const=0, method = "gibbs") #run EBMA algorithm on data
